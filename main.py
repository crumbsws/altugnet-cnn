# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-vN0Itp5Y99MLu10hUMFWfDNRU7g5yJK
"""

# Importing dependencies
import torch
import os
from colorama import Fore, Back, Style
from PIL import Image
from torch import nn,save,load
from torch.optim import Adam
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# Loading Data
transform = transforms.Compose([transforms.ToTensor()])
train_dataset = datasets.MNIST(root="data", download=True, train=True, transform=transform)
test_dataset = datasets.MNIST(root="data", download=True, train=False, transform=transform)

test_loader = DataLoader(test_dataset, batch_size=1, shuffle=True)
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)

# Define the image classifier model
class ImageClassifier(nn.Module):
    def __init__(self):
        super(ImageClassifier, self).__init__()
        self.conv_layers = nn.Sequential(
            nn.Conv2d(1, 32, kernel_size=3),
            nn.ReLU(),
            nn.Conv2d(32, 64, kernel_size=3),
            nn.ReLU(),
            nn.Conv2d(64, 64, kernel_size=3),
            nn.ReLU()
        )
        self.fc_layers = nn.Sequential(
            nn.Flatten(),
            nn.Linear(64 * 22 * 22, 10)
        )

    def forward(self, x):
        x = self.conv_layers(x)
        x = self.fc_layers(x)
        return x

#add code here to check 'ıf model_state.pt, exısts then just load the model
if not os.path.exists('model_state.pt'):
  # Create an instance of the image classifier model
  device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
  classifier = ImageClassifier().to(device)

  # Define the optimizer and loss function
  optimizer = Adam(classifier.parameters(), lr=0.001)
  loss_fn = nn.CrossEntropyLoss()

  loss_list = []

  # Train the model
  for epoch in range(10):  # Train for 10 epochs
      for images, labels in train_loader:
          images, labels = images.to(device), labels.to(device)
          optimizer.zero_grad()  # Reset gradients
          outputs = classifier(images)  # Forward pass
          loss = loss_fn(outputs, labels)  # Compute loss
          loss.backward()  # Backward pass
          optimizer.step()  # Update weights

      loss_list.append(loss.item())
      print(f"Epoch:{epoch} loss is {loss.item()}")
      print(f"Comparing old loss to the new one: {loss_list[epoch - 1] - loss_list[epoch]} ")
      print('--------------------------------------')

  # Save the trained model
  torch.save(classifier.state_dict(), 'model_state.pt')

else:
  classifier = ImageClassifier()
  device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
  classifier.to(device)
  # Load the saved model
  with open('model_state.pt', 'rb') as f:
     classifier.load_state_dict(load(f))



test_loss_list = []
test_accuracy_list = []
for images, labels in test_loader:
    images, labels = images.to(device), labels.to(device)
    outputs = classifier(images)  # Forward pass
    loss_fn = nn.CrossEntropyLoss()
    loss = loss_fn(outputs, labels)  # Compute loss
    test_loss_list.append(loss.item())

    #now lets actually compute test accuracy
    _, predicted = torch.max(outputs, 1)
    total = labels.size(0)
    correct = (predicted == labels).sum().item()
    accuracy = correct / total
    test_accuracy_list.append(accuracy)

avg_test_loss = sum(test_loss_list) / len(test_loss_list)



second_test_accuracy_list = []
altered_example_img = None
non_altered_example_img = None

for images, labels in test_loader:



    images, labels = images.to(device), labels.to(device)
    images.requires_grad = True

    non_altered_example_img = images

    outputs_OG = classifier(images)  # Forward pass
    loss_fn = nn.CrossEntropyLoss()
    loss = loss_fn(outputs_OG, labels)
    loss.backward()
    grad_adv = images.grad
    epsilon = 0.1


    #take sıgn of each element
    grad_adv = torch.sign(grad_adv)
    x_adv = images + epsilon * grad_adv
    altered_example_img = x_adv

    outputs_adv = classifier(x_adv)  # Forward pass


    #now lets actually compute test accuracy
    _, adv_predicted = torch.max(outputs_adv, 1)
    adv_total = labels.size(0)
    adv_correct = (adv_predicted == labels).sum().item()
    adv_accuracy = adv_correct / adv_total
    second_test_accuracy_list.append(adv_accuracy)



    images.grad.zero_()





#
#pass ımage through network
#calculate the loss
#calculate the gradıent of the loss. loss.backward()
#then store the gradıent wrt x usıng grad = x.grad
# x_adv = x + epsılon* sıng(grad)

print(Fore.RED + f"Resultant accuracy from the plain test dataset: {sum(test_accuracy_list) / len(test_accuracy_list)}")
print(Fore.YELLOW + f"Average test loss: {avg_test_loss}")
print(Fore.RED + f"Resultant accuracy from the adversarial attack: {sum(second_test_accuracy_list) / len(second_test_accuracy_list)}")


print(Fore.YELLOW + '-------------------------------------------------------')

print(Fore.GREEN + "Original Image Example: \n")
plt.imshow(non_altered_example_img.squeeze().cpu().detach().numpy(), cmap='gray')
plt.show()

print('')

print(Fore.GREEN + "Altered Image Example: \n")
plt.imshow(altered_example_img.squeeze().cpu().detach().numpy(), cmap='gray')
plt.show()

# Perform inference on an image

